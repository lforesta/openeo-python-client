.. openeo documentation master file, created by
   sphinx-quickstart on Fri Oct  6 13:02:27 2017.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Open-EO Client
==============


.. image:: https://img.shields.io/badge/Status-proof--of--concept-yellow.svg

Usage
==================================

.. automodule:: openeo

.. toctree::
   :maxdepth: 3
   :caption: Contents:

Example: Simple band math
-------------------------
A common task in earth observation, is to apply a formula to a number of bands
in order to compute an 'index', such as NDVI, NDWI, EVI, ...

Begin by importing the openeo module::

    >>> import openeo

Now we need to connect to a backend::

    >>> connection = openeo.connect('http://openeo.vgt.vito.be/openeo/0.4.0')

Now, we have a :class:`Connection <openeo.Connection>` object called ``connection``. We can
This object is our entry point to the backend, and allows us to discover its capabilities.

Information about a backend is most easily found on the OpenEO HUB: http://hub.openeo.org/

Band math usually starts from a raster data cube, with multiple spectral bands available.
The backend used here has a Sentinel-2 collection: CGS_SENTINEL2_RADIOMETRY_V102_001

    >>> sentinel2_data_cube = connection.imagecollection("CGS_SENTINEL2_RADIOMETRY_V102_001")

Now we have a :class:`ImageCollection <openeo.ImageCollection>` object called ``sentinel2_data_cube``.
Creating this object does not yet load any data, but virtually it can contain quite a lot of data.
Therefore, we need to filter it before we can use it::

    >>> sentinel2_data_cube = sentinel2_data_cube.filter_daterange(extent=["2016-01-01","2016-03-10"]) \
                               .filter_bbox(west=5.15183687210083,east=5.153381824493408,south=51.18192559252128,north=51.18469636040683,crs="EPSG:4326")


On this data cube, we can now select the individual bands::

    >>> B02 = sentinel2_data_cube.band('2')
        B04 = sentinel2_data_cube.band('4')
        B08 = sentinel2_data_cube.band('8')

In this example, we'll compute the enhanced vegetation index (EVI)::

    >>> evi_cube = (2.5 * (B08 - B04)) / ((B08 + 6.0 * B04 - 7.5 * B02) + 1.0)
        evi_cube.download("out.geotiff",format="GeoTIFF")


Example: Applying a mask
________________________

It is very common for earth observation data to have separate masking layers that for instance indicate
whether a pixel is covered by a (type of) cloud or not. For Sentinel-2, one such layer is the 'scene classification'
layer that is generated by the Sen2Cor algorithm. In this example, we will use this layer to mask clouds out of our data.

First we load data, and create a binary mask. Vegetation pixels have a value of '4' in the scene classification, so we set these
pixels to 0 and all other pixels to 1 using a simple comparison::

   >>> s2_sceneclassification = session.imagecollection("S2_FAPAR_SCENECLASSIFICATION_V102_PYRAMID") \
                           .filter_daterange(extent=["2016-01-01","2016-03-10"]) \
                          .filter_bbox(west=5.15183687210083,east=5.153381824493408,south=51.18192559252128,north=51.18469636040683,crs="EPSG:4326")

      mask = s2_sceneclassification.band('classification')

      mask = mask != 4
      mask

Once the mask is created, it can be applied to the cube:

   >>> evi_cube_masked = evi_cube.mask(rastermask=mask)

Example: Smoothing timeseries with a user defined function (UDF)
----------------------------------------------------------------

User defined functions are a very important feature of OpenEO. They allow you as a user to
reuse existing code, by submitting it to the backend.

In this example, we start from the 'evi_cube' that was created in the previous example, and want to
apply a temporal smoothing on it. More specifically, we want to use the "Savitzky Golay" smoother
that is available in the SciPy Python library.

The user defined function implementation needs to follow a specification, that is defined here:
https://github.com/Open-EO/openeo-udf

This is an example that follows the spec:

.. literalinclude:: ../examples/udf/smooth_savitzky_golay.py
    :caption: UDF code
    :name: savgol_udf

Once the UDF is defined in a separate file, we need to load it::

    >>> def get_resource(relative_path):
            return str(Path( relative_path))

        def load_udf(relative_path):
            import json
            with open(get_resource(relative_path), 'r+') as f:
                return f.read()

        smoothing_udf = load_udf('udf/smooth_savitzky_golay.py')
        print(smoothing_udf)

after that, we can simply apply it along a dimension::

    >>> smoothed_evi = evi_cube_masked.apply_dimension(smoothing_udf,runtime='Python')


API
===

High level Interface
--------------------

The high-level interface tries to provide an opinionated, Pythonic, API
to interact with OpenEO backends. It's aim is to hide some of the details
of using a web service, so the user can produce concise and readable code.

Users that want to interact with OpenEO on a lower level, and have more control, can
use the lower level classes.

.. autofunction:: openeo.connect


openeo.rest.connection
-------------------------

.. automodule:: openeo.rest.connection
   :members: Connection OpenEoApiError


openeo.rest.imagecollectionclient
----------------------------------

.. automodule:: openeo.rest.imagecollectionclient
   :members: ImageCollectionClient




.. toctree::
   :maxdepth: 3
   :caption: Contents:

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
